#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif

#include "gpio.h"
#include "config.h"

/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */
// Define the custom keycode
enum custom_keycodes
{
    RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE = SAFE_RANGE,
    RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_SIMPLE,
    RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_MULTIWIDE,
    RGB_SET_EFFECT_MATRIX_TYPING_HEATMAP,
    RGB_SET_EFFECT_MATRIX_CYCLE_UP_DOWN,
    RGB_PLAY_ANIMATION_SLIDESHOW,
    KEYCODE_VIM_NEXT_TAB,
    KEYCODE_VIM_PREV_TAB,
    KEYCODE_TMUX_NEXT_TAB,
    KEYCODE_TMUX_PREV_TAB,
    KEYCODE_TMUX_VI_MODE,
};

// RGB MODE EFFECTS KEYCODES
#define RM_EFF1     RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE
#define RM_EFF2     RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_SIMPLE
#define RM_EFF3     RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_MULTIWIDE
#define RM_EFF4     RGB_SET_EFFECT_MATRIX_TYPING_HEATMAP
#define RM_EFF5     RGB_SET_EFFECT_MATRIX_CYCLE_UP_DOWN
#define RM_ANWT     RGB_PLAY_ANIMATION_SLIDESHOW

// VIM KEYCODES
#define KC_VNTB     KEYCODE_VIM_NEXT_TAB
#define KC_VPTB     KEYCODE_VIM_PREV_TAB

// TMUX KEYCODES
#define KC_TNTB     KEYCODE_TMUX_NEXT_TAB
#define KC_TPTB     KEYCODE_TMUX_PREV_TAB
#define KC_TVMO     KEYCODE_TMUX_VI_MODE

// TMUX KEYCODES

// Define the unwanted modes (to be skipped)
#define IS_UNWANTED_MODE(mode) ((mode) == RGB_MATRIX_NONE || \
                                (mode) == RGB_MATRIX_SOLID_COLOR || \
                                (mode) == RGB_MATRIX_GRADIENT_UP_DOWN || \
                                (mode) == RGB_MATRIX_GRADIENT_LEFT_RIGHT || \
                                (mode) == RGB_MATRIX_TYPING_HEATMAP || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_SIMPLE || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_SIMPLE_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_WIDE || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_WIDE_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTIWIDE || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTIWIDE_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_CROSS || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_CROSS_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTICROSS || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTICROSS_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_NEXUS || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_NEXUS_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTINEXUS || \
                                (mode) == RGB_MATRIX_SOLID_REACTIVE_MULTINEXUS_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SPLASH || \
                                (mode) == RGB_MATRIX_SPLASH_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_MULTISPLASH || \
                                (mode) == RGB_MATRIX_MULTISPLASH_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_SPLASH || \
                                (mode) == RGB_MATRIX_SOLID_SPLASH_WITH_UNDERGLOW || \
                                (mode) == RGB_MATRIX_SOLID_MULTISPLASH || \
                                (mode) == RGB_MATRIX_SOLID_MULTISPLASH_WITH_UNDERGLOW)

enum layers
{
    _DEFAULT = 0,
    _RAISE,
    _RGB_EFFECT_AND_MEDIA
};

// Timer variable to track inactivity
static bool idle = false;
static uint32_t inactivity_timer = 0;
static uint32_t change_animation_timer = 0;
static bool rgb_play_animation_slideshow = false;

static void refresh_inactivity_timer(void);
static void play_next_rgb_effect(void);
static void start_play_animation_slideshow(void);
static void stop_animation_slideshow(void);

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [_DEFAULT] = LAYOUT(
        KC_GRV , KC_1   , KC_2   , KC_3   , KC_4   , KC_5   ,                   KC_6   , KC_7   , KC_8   , KC_9   , KC_0   , KC_BSPC,
        KC_TAB , KC_Q   , KC_W   , KC_E   , KC_R   , KC_T   ,                   KC_Y   , KC_U   , KC_I   , KC_O   , KC_P   , KC_BSLS,
        KC_ESC , KC_A   , KC_S   , KC_D   , KC_F   , KC_G   ,                   KC_H   , KC_J   , KC_K   , KC_L   , KC_SCLN, KC_QUOT,
        KC_LSFT, KC_Z   , KC_X   , KC_C   , KC_V   , KC_B   , KC_LBRC, KC_RBRC, KC_N   , KC_M   , KC_COMM, KC_DOT , KC_SLSH, KC_RSFT,
                                   KC_LCTL, KC_LALT, KC_LGUI, KC_SPC , KC_ENT , MO(1)  , KC_MINS, KC_EQL
    ),
    [_RAISE] = LAYOUT(
        KC_F1  , KC_F2  , KC_F3  , KC_F4  , KC_F5  , KC_F6  ,                   XXXXXXX, XXXXXXX, XXXXXXX, KC_MINS, KC_EQL , KC_DEL ,
        KC_F7  , KC_F8  , KC_F9  , KC_F10 , KC_F11 , KC_F12 ,                   XXXXXXX, KC_HOME, KC_END , KC_LBRC, KC_RBRC, XXXXXXX,
        KC_CAPS, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX,                   KC_LEFT, KC_DOWN, KC_UP  , KC_RGHT, XXXXXXX, XXXXXXX,
        _______, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, KC_TVMO, KC_TPTB, KC_TNTB, KC_VPTB, KC_VNTB, XXXXXXX, _______,
                                   _______, _______, MO(2)  , _______, _______, _______, KC_BRID, KC_BRIU
    ),
    [_RGB_EFFECT_AND_MEDIA] = LAYOUT(
        RM_ANWT, RM_EFF1, RM_EFF2, RM_EFF3, RM_EFF4, RM_EFF5,                   XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX,
        RM_TOGG, RM_NEXT, RM_HUEU, RM_SATU, RM_VALU, RM_SPDU,                   XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX,
        XXXXXXX, RM_PREV, RM_HUED, RM_SATD, RM_VALD, RM_SPDD,                   XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX,
        XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, KC_MUTE, KC_MPRV, KC_MNXT, KC_MPLY, XXXXXXX,
                                   XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, XXXXXXX, KC_VOLD, KC_VOLU
    )
};

//SSD1306 OLED update loop, make sure to enable OLED_ENABLE=yes in rules.mk
#ifdef OLED_ENABLE

oled_rotation_t oled_init_user(oled_rotation_t rotation) {
  if (!is_keyboard_master())
    return OLED_ROTATION_180;  // flips the display 180 degrees if offhand
  return rotation;
}

// When you add source files to SRC in rules.mk, you can use functions.
const char *read_layer_state(void);
const char *read_logo(void);
void set_keylog(uint16_t keycode, keyrecord_t *record);
const char *read_keylog(void);
const char *read_keylogs(void);

// const char *read_mode_icon(bool swap);
// const char *read_host_led_state(void);
// void set_timelog(void);
// const char *read_timelog(void);

char wpm_str[16];

// WPM-responsive animation stuff here
#define IDLE_FRAMES 5
#define IDLE_SPEED 10 // below this wpm value your animation will idle

// #define PREP_FRAMES 1 // uncomment if >1

#define TAP_FRAMES 2
#define TAP_SPEED 30 // above this wpm value typing animation to triggere

#define ANIM_FRAME_DURATION 200 // how long each frame lasts in ms
#define SLEEP_TIMER 60000 // should sleep after this period of 0 wpm, may need fixing
#define ANIM_SIZE 640 // number of bytes in array, minimize for adequate firmware size, max is 1024

uint32_t anim_timer = 0;
uint32_t anim_sleep = 0;
uint8_t current_idle_frame = 0;
uint8_t current_tap_frame = 0;

uint32_t master_anim_timer = 0;
uint32_t master_anim_sleep = 0;
uint8_t master_current_idle_frame = 0;
uint8_t master_current_tap_frame = 0;

// Render right OLED display animation
static void render_anim(void) {

  // Idle animation
  static const char PROGMEM idle[IDLE_FRAMES][ANIM_SIZE] = {
    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,16,8,8,4,4,4,8,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,100,130,2,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
      64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,56,4,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,16,8,8,4,4,4,8,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,100,130,2,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
      64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,56,4,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,
      7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,64,64,64,64,32,32,32,32,16,8,4,2,2,4,24,96,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,194,1,1,2,2,4,4,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,96,0,129,130,130,132,8,16,32,64,128,0,0,0,0,128,128,128,128,64,64,64,64,32,
      32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,25,6,0,0,0,0,0,0,0,24,24,24,27,3,0,64,160,34,36,20,18,18,18,11,8,8,8,8,5,5,9,9,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,
      64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,
      7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,8,4,2,2,2,4,56,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,226,1,1,2,2,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,192,193,193,194,4,8,16,32,64,128,0,0,0,128,128,128,128,64,64,64,64,
      32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,12,12,12,13,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,2,2,4,4,8,8,8,8,8,7,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    }
  };

  // Prep animation
  static const char PROGMEM prep[][ANIM_SIZE] = {

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,129,128,128,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,225,26,6,9,49,53,1,138,124,0,0,128,128,128,128,64,64,
      64,64,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,24,6,5,152,153,132,195,124,65,65,64,64,32,33,34,18,17,17,17,9,8,8,8,8,4,4,4,4,4,4,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    }

  };

  // Typing animation
  static const char PROGMEM tap[TAP_FRAMES][ANIM_SIZE] = {

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,248,248,248,248,0,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,129,128,128,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,1,2,4,8,16,32,67,135,7,1,0,184,188,190,159,
      95,95,79,76,32,32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,24,6,5,152,153,132,67,124,65,65,64,64,32,33,34,18,17,17,17,9,8,8,8,8,4,4,8,8,16,16,16,16,16,17,15,1,61,124,252,252,252,252,252,60,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,2,2,1,1,1,
      1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    },

    {
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,0,0,128,64,64,32,32,32,32,16,16,16,16,8,4,2,1,1,2,12,48,64,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,30,225,0,0,1,1,2,2,1,0,0,0,0,128,128,0,0,0,0,0,0,0,0,0,128,0,48,48,0,0,1,225,26,6,9,49,53,1,138,124,0,0,128,128,128,128,64,64,64,64,32,
      32,32,32,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,112,12,3,0,0,0,0,0,0,0,0,0,0,1,1,0,64,160,33,34,18,17,17,17,9,8,8,8,8,4,4,4,4,4,4,2,2,2,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,128,128,128,64,64,64,64,64,32,32,32,32,32,16,16,16,16,16,8,8,8,8,8,4,4,4,4,4,2,3,122,122,121,121,121,121,57,49,2,2,4,4,8,8,8,136,136,135,128,
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    }

  };

  //assumes 1 frame prep stage
    void animation_phase(void) {
        if(get_current_wpm() <=IDLE_SPEED){
            current_idle_frame = (current_idle_frame + 1) % IDLE_FRAMES;
            oled_clear();
            oled_write_raw_P(idle[abs((IDLE_FRAMES-1)-current_idle_frame)], ANIM_SIZE);
        }
        if(get_current_wpm() >IDLE_SPEED && get_current_wpm() <TAP_SPEED){
            oled_clear();
            // oled_write_raw_P(prep[abs((PREP_FRAMES-1)-current_prep_frame)], ANIM_SIZE); // uncomment if IDLE_FRAMES >1
            oled_write_raw_P(prep[0], ANIM_SIZE); // remove if IDLE_FRAMES >1
        }
        if(get_current_wpm() >=TAP_SPEED){
            current_tap_frame = (current_tap_frame + 1) % TAP_FRAMES;
            oled_clear();
            oled_write_raw_P(tap[abs((TAP_FRAMES-1)-current_tap_frame)], ANIM_SIZE);
        }
    }
    if(get_current_wpm() != 0) {
        if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
            anim_timer = timer_read32();
            animation_phase();
        }
        anim_sleep = timer_read32();
    } else {
        if(timer_elapsed32(anim_timer) > ANIM_FRAME_DURATION) {
            anim_timer = timer_read32();
            animation_phase();
        }
        if(timer_elapsed32(anim_sleep) > SLEEP_TIMER) {
//            oled_off();
        }
    }
}

// forward declare from aurora/lily58/lily58.c
void render_space(void);
void render_mod_status_gui_alt(uint8_t modifiers);
void render_mod_status_ctrl_shift(uint8_t modifiers);
void render_kb_LED_state(void);

void render_anim_master(void)
{
    static const char PROGMEM bogo_cat_tap[TAP_FRAMES][ANIM_SIZE] =
    {
        {
            // 'cat-typing-anim-1', 32x24px
            0x00, 0x00, 0x00, 0x80, 0xc0, 0xc0, 0x80, 0xc0, 0x60, 0x20, 0x10, 0x18, 0x08, 0x0c, 0x02, 0x06,
            0x0c, 0x18, 0x10, 0x30, 0x20, 0x60, 0x60, 0xc0, 0x80, 0x80, 0x80, 0x80, 0xc0, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x0f, 0x3f, 0x30, 0x24, 0x21, 0x61, 0x40, 0x40, 0xc4, 0xc6, 0x80, 0x88, 0x98, 0x10,
            0x00, 0x00, 0x00, 0x60, 0x20, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x78, 0xff, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
            0x01, 0x33, 0x62, 0x0f, 0x11, 0x50, 0x58, 0x08, 0x0c, 0x0c, 0x0c, 0x08, 0x19, 0x1f, 0x18, 0x00
        },
        {
            // 'cat-typing-anim-2', 32x24px
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0x60, 0x20, 0x10, 0x18, 0x08, 0x0c, 0x02, 0x06,
            0x0c, 0x18, 0x10, 0x30, 0x20, 0x60, 0x60, 0xc0, 0x80, 0x80, 0x80, 0x80, 0xc0, 0x00, 0x00, 0x00,
            0x80, 0x80, 0xf0, 0x98, 0x86, 0x83, 0x81, 0x80, 0xc0, 0x40, 0xc4, 0xc6, 0x80, 0x88, 0x98, 0x10,
            0x00, 0x00, 0x00, 0x60, 0xe0, 0xf0, 0x98, 0x98, 0x30, 0x21, 0x01, 0x78, 0xff, 0x00, 0x00, 0x00,
            0x01, 0x03, 0x00, 0x01, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
            0x01, 0x03, 0x03, 0x02, 0x03, 0x06, 0x04, 0x04, 0x0c, 0x0c, 0x08, 0x08, 0x19, 0x1f, 0x18, 0x00
        }
    };

    void animation_phase_master(void)
    {
        if(get_current_wpm() >=TAP_SPEED){
            master_current_tap_frame = (master_current_tap_frame + 1) % TAP_FRAMES;
            oled_clear();
            oled_write_raw_P(bogo_cat_tap[abs((TAP_FRAMES-1)-master_current_tap_frame)], ANIM_SIZE);
        }
    }

    if(get_current_wpm() != 0)
    {
        if(timer_elapsed32(master_anim_timer) > ANIM_FRAME_DURATION)
        {
            master_anim_timer = timer_read32();
            animation_phase_master();
        }
        master_anim_sleep = timer_read32();
    }
    else
    {
        oled_clear();
        oled_write_raw_P(bogo_cat_tap[abs((TAP_FRAMES-1)-master_current_tap_frame)], ANIM_SIZE);
    }
}

void render_custom_logo(void)
{
    render_anim_master();
    oled_set_cursor(0, 3);
    render_space();
}

void render_wpm_counter(void)
{
    oled_write_P(PSTR("WPM: "), false);
    oled_write(get_u8_str(get_current_wpm(), ' '), false);
    oled_set_cursor(0, 6);
}

void render_custom_layer_state(void)
{
    static const char PROGMEM default_layer[] = {
        0x20, 0x97, 0x98, 0x99, 0x20,
        0x20, 0xb7, 0xb8, 0xb9, 0x20,
        0x20, 0xd7, 0xd8, 0xd9, 0x20, 0};
    static const char PROGMEM raise_layer[] = {
        0x20, 0x94, 0x95, 0x96, 0x20,
        0x20, 0xb4, 0xb5, 0xb6, 0x20,
        0x20, 0xd4, 0xd5, 0xd6, 0x20, 0};
    static const char PROGMEM rgb_effect_and_media_layer[] = {
        0x20, 0x9a, 0x9b, 0x9c, 0x20,
        0x20, 0xba, 0xbb, 0xbc, 0x20,
        0x20, 0xda, 0xdb, 0xdc, 0x20, 0};

    switch (get_highest_layer(layer_state | default_layer_state)) {
        case _RGB_EFFECT_AND_MEDIA:
            oled_write_P(rgb_effect_and_media_layer, false);
            break;
        case _RAISE:
            oled_write_P(raise_layer, false);
            break;
        default:
            oled_write_P(default_layer, false);
    }
}

void render_rgb_info(void)
{
    oled_clear();
    oled_write_P(PSTR("ST:"), false);
    oled_write(get_u8_str(rgblight_is_enabled(), ' '), false);
    oled_write_P(PSTR(" MO:"), false);
    oled_write(get_u8_str(rgblight_get_mode(), ' '), false);
    oled_write_P(PSTR(" HU:"), false);
    oled_write(get_u8_str(rgblight_get_hue(), ' '), false);
    oled_set_cursor(0, 2);
    oled_write_P(PSTR("SA:"), false);
    oled_write(get_u8_str(rgblight_get_sat(), ' '), false);
    oled_write_P(PSTR(" VA:"), false);
    oled_write(get_u8_str(rgblight_get_val(), ' '), false);
    oled_write_P(PSTR(" SP:"), false);
    oled_write(get_u8_str(rgblight_get_speed(), ' '), false);
}

bool oled_task_user(void) {
    if (is_keyboard_master()) {
        render_custom_logo();
        render_wpm_counter();
        render_space();
        render_custom_layer_state();
        render_space();
        render_mod_status_gui_alt(get_mods()|get_oneshot_mods());
        render_mod_status_ctrl_shift(get_mods()|get_oneshot_mods());
        render_kb_LED_state();
    } else {
        if(_RGB_EFFECT_AND_MEDIA == get_highest_layer(layer_state))
        {
            render_rgb_info();
        }
        else
        {
            render_anim();
        }
    }
    return false;
}
#endif // OLED_DRIVER_ENABLE

// Disable MCU LED. It is used as CAPSLOCK indicator instead. See config.h
void keyboard_pre_init_user(void)
{
    gpio_set_pin_output(24);
    gpio_write_pin_high(24);
}

void keyboard_post_init_user(void)
{
    inactivity_timer = timer_read32();
}

// Define what happens when the custom key is pressed
bool process_record_user(uint16_t keycode, keyrecord_t *record)
{

    if(record->event.pressed)
    {
        #ifdef OLED_ENABLE
        set_keylog(keycode, record);
        #endif

        #if defined(INACTIVITY_TIMEOUT) && defined(CHANGE_ANIMATION_TIMEOUT)
        refresh_inactivity_timer();

        if(rgb_play_animation_slideshow)
        {
            stop_animation_slideshow();
        }
        #endif // defined(INACTIVITY_TIMEOUT) && defined(CHANGE_ANIMATION_TIMEOUT)
    }


    // Add custom behavior for other keycodes if needed
    switch(keycode)
    {
        case RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE:
        {
            if(record->event.pressed)
            {
                rgb_matrix_mode(RGB_MATRIX_SOLID_REACTIVE);
            }
            return false;
        }
        case RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_SIMPLE:
        {
            if(record->event.pressed)
            {
                rgb_matrix_mode(RGB_MATRIX_SOLID_REACTIVE_SIMPLE);
            }
            return false;
        }
        case RGB_SET_EFFECT_MATRIX_SOLID_REACTIVE_MULTIWIDE:
        {
            if(record->event.pressed)
            {
                rgb_matrix_mode(RGB_MATRIX_SOLID_REACTIVE_MULTIWIDE);
            }
            return false;
        }

        case RGB_SET_EFFECT_MATRIX_TYPING_HEATMAP:
        {
            if(record->event.pressed)
            {
                rgb_matrix_mode(RGB_MATRIX_TYPING_HEATMAP);
            }
            return false;
        }
        case RGB_SET_EFFECT_MATRIX_CYCLE_UP_DOWN:
        {
            if(record->event.pressed)
            {
                rgb_matrix_mode(RGB_MATRIX_CYCLE_UP_DOWN);
            }
            return false;
        }
        case RGB_PLAY_ANIMATION_SLIDESHOW:
        {
            if(record->event.pressed)
            {
                start_play_animation_slideshow();
            }
            return false;
        }
        case KEYCODE_VIM_NEXT_TAB:
        {
            if(record->event.pressed)
            {
                // Send 'g' and 't' sequentially
                tap_code(KC_G);
                tap_code(KC_T);
            }
            return false;
        }
        case KEYCODE_VIM_PREV_TAB:
        {
            if(record->event.pressed)
            {
                // Send 'g' and 't' sequentially
                tap_code(KC_G);
                // Send 'Shift + T'
                tap_code16(S(KC_T));
            }
            return false;
        }
        case KEYCODE_TMUX_NEXT_TAB:
        {
            if(record->event.pressed)
            {
                // Send Ctrl-B (equivalent to Escape)
                tap_code16(C(KC_B));  // C() sends Ctrl + key
                // Send 'n'
                tap_code(KC_N);
            }
            return false;
        }
        case KEYCODE_TMUX_PREV_TAB:
        {
            if(record->event.pressed)
            {
                // Send Ctrl-B (equivalent to Escape)
                tap_code16(C(KC_B));  // C() sends Ctrl + key
                // Send 'n'
                tap_code(KC_P);
            }
            return false;
        }
        case KEYCODE_TMUX_VI_MODE:
        {
            if(record->event.pressed)
            {
                // Send Ctrl-B (equivalent to Escape)
                tap_code16(C(KC_B));  // C() sends Ctrl + key
                // Send 'n'
                tap_code(KC_LBRC);
            }
            return false;
        }

        default:
            return true; // Return true to allow normal processing for other keycodes
    }
}

void housekeeping_task_user(void)
{
#if defined(INACTIVITY_TIMEOUT) && defined(CHANGE_ANIMATION_TIMEOUT)
    if(rgb_play_animation_slideshow)
    {
        if(timer_elapsed32(change_animation_timer) > CHANGE_ANIMATION_TIMEOUT)
        {
            play_next_rgb_effect();
            change_animation_timer = timer_read32(); // Reset the timer after the change
        }
    }

    if((!idle) && (timer_elapsed32(inactivity_timer) > INACTIVITY_TIMEOUT))
    {
        idle = true;
        start_play_animation_slideshow();
    }

#endif // define(INACTIVITY_TIMEOUT) && define(CHANGE_ANIMATION_TIMEOUT)
}

static void refresh_inactivity_timer(void)
{
    inactivity_timer = timer_read32();
    if(idle)
    {
        idle = false;
    }
}


static void play_next_rgb_effect(void)
{
    // Start at RGB_MATRIX_CYCLE_UP_DOWN
    static uint8_t current_rgb_mode = RGB_MATRIX_CYCLE_UP_DOWN;
    // Increment the mode index and check if itâ€™s unwanted
    do
    {
        current_rgb_mode = (current_rgb_mode + 1) % RGB_MATRIX_EFFECT_MAX;
    }
    while(IS_UNWANTED_MODE(current_rgb_mode));

    rgb_matrix_mode_noeeprom(current_rgb_mode);
}

static void start_play_animation_slideshow(void)
{
    rgb_play_animation_slideshow = true;
    // force timeout
    change_animation_timer = timer_read32() + CHANGE_ANIMATION_TIMEOUT;
}


static void stop_animation_slideshow(void)
{
    rgb_matrix_reload_from_eeprom();
    rgb_play_animation_slideshow = false;
}


#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C

